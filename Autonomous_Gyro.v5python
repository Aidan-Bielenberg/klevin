{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ncontroller_1 = Controller(PRIMARY)\nTopLeft = Motor(Ports.PORT9, GearSetting.RATIO_18_1, False)\nBottomLeft = Motor(Ports.PORT11, GearSetting.RATIO_18_1, False)\nTopRight = Motor(Ports.PORT13, GearSetting.RATIO_18_1, True)\nBottomRight = Motor(Ports.PORT12, GearSetting.RATIO_18_1, True)\nIdependantMotor = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nRollersMotor = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nLeftIntake = Motor(Ports.PORT10, GearSetting.RATIO_6_1, False)\nRightIntake = Motor(Ports.PORT20, GearSetting.RATIO_6_1, True)\ninertial_3 = Inertial(Ports.PORT3)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\nvexcode_brain_precision = 0\nvexcode_console_precision = 0\nvexcode_controller_1_precision = 0\nVelocity = 0\nerror = 0\noutput = 0\nactual_error = 0\ny = 0\n\ndef Turn_Right_number_Rotations(Turn_Right_number_Rotations__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.spin_for(FORWARD, Turn_Right_number_Rotations__number, TURNS, wait=False)\n    TopRight.spin_for(REVERSE, Turn_Right_number_Rotations__number, TURNS, wait=False)\n    BottomLeft.spin_for(FORWARD, Turn_Right_number_Rotations__number, TURNS, wait=False)\n    BottomRight.spin_for(REVERSE, Turn_Right_number_Rotations__number, TURNS, wait=True)\n\ndef Forward_number_Rotations_7C_and_don_t_wait(Forward_number_Rotations_7C_and_don_t_wait__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.spin_for(FORWARD, Forward_number_Rotations_7C_and_don_t_wait__number, TURNS, wait=False)\n    TopRight.spin_for(FORWARD, Forward_number_Rotations_7C_and_don_t_wait__number, TURNS, wait=False)\n    BottomLeft.spin_for(FORWARD, Forward_number_Rotations_7C_and_don_t_wait__number, TURNS, wait=False)\n    BottomRight.spin_for(FORWARD, Forward_number_Rotations_7C_and_don_t_wait__number, TURNS, wait=False)\n\ndef Set_Drive_Velocity_Velocity__25(Set_Drive_Velocity_Velocity__25__Velocity):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.set_velocity(Set_Drive_Velocity_Velocity__25__Velocity, PERCENT)\n    BottomLeft.set_velocity(Set_Drive_Velocity_Velocity__25__Velocity, PERCENT)\n    TopRight.set_velocity(Set_Drive_Velocity_Velocity__25__Velocity, PERCENT)\n    BottomRight.set_velocity(Set_Drive_Velocity_Velocity__25__Velocity, PERCENT)\n    Velocity = Set_Drive_Velocity_Velocity__25__Velocity\n\ndef Turn_Left_To_number_Degrees(Turn_Left_To_number_Degrees__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    while not (inertial_3.rotation(DEGREES) < Turn_Left_To_number_Degrees__number * -1 + 7 or inertial_3.rotation(DEGREES) == Turn_Left_To_number_Degrees__number * -1 + 7):\n        TopLeft.spin(REVERSE)\n        TopRight.spin(FORWARD)\n        BottomRight.spin(FORWARD)\n        BottomLeft.spin(REVERSE)\n        wait(5, MSEC)\n    TopLeft.stop()\n    TopRight.stop()\n    BottomLeft.stop()\n    BottomRight.stop()\n\ndef Strafe_Right_number_Rotations(Strafe_Right_number_Rotations__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.spin_for(FORWARD, Strafe_Right_number_Rotations__number, TURNS, wait=False)\n    TopRight.spin_for(REVERSE, Strafe_Right_number_Rotations__number, TURNS, wait=False)\n    BottomLeft.spin_for(REVERSE, Strafe_Right_number_Rotations__number, TURNS, wait=False)\n    BottomRight.spin_for(FORWARD, Strafe_Right_number_Rotations__number, TURNS, wait=True)\n\ndef Turn_Left_number_Rotations(Turn_Left_number_Rotations__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.spin_for(REVERSE, Turn_Left_number_Rotations__number, TURNS, wait=False)\n    TopRight.spin_for(FORWARD, Turn_Left_number_Rotations__number, TURNS, wait=False)\n    BottomLeft.spin_for(REVERSE, Turn_Left_number_Rotations__number, TURNS, wait=False)\n    BottomRight.spin_for(FORWARD, Turn_Left_number_Rotations__number, TURNS, wait=True)\n\ndef Turn_Right_To_number_Degrees(Turn_Right_To_number_Degrees__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    while not (inertial_3.rotation(DEGREES) > Turn_Right_To_number_Degrees__number - 7 or inertial_3.rotation(DEGREES) == Turn_Right_To_number_Degrees__number - 7):\n        TopLeft.spin(FORWARD)\n        TopRight.spin(REVERSE)\n        BottomRight.spin(REVERSE)\n        BottomLeft.spin(FORWARD)\n        wait(5, MSEC)\n    TopLeft.stop()\n    TopRight.stop()\n    BottomLeft.stop()\n    BottomRight.stop()\n\ndef Forward_number_Rotations(Forward_number_Rotations__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.spin_for(FORWARD, Forward_number_Rotations__number, TURNS, wait=False)\n    TopRight.spin_for(FORWARD, Forward_number_Rotations__number, TURNS, wait=False)\n    BottomLeft.spin_for(FORWARD, Forward_number_Rotations__number, TURNS, wait=False)\n    BottomRight.spin_for(FORWARD, Forward_number_Rotations__number, TURNS, wait=True)\n\ndef Strafe_Left_number_Rotations(Strafe_Left_number_Rotations__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.spin_for(REVERSE, Strafe_Left_number_Rotations__number, TURNS, wait=False)\n    TopRight.spin_for(FORWARD, Strafe_Left_number_Rotations__number, TURNS, wait=False)\n    BottomLeft.spin_for(FORWARD, Strafe_Left_number_Rotations__number, TURNS, wait=False)\n    BottomRight.spin_for(REVERSE, Strafe_Left_number_Rotations__number, TURNS, wait=True)\n\ndef Drive_Distance_Heading_Velocity_kp(Drive_Distance_Heading_Velocity_kp__Distance, Drive_Distance_Heading_Velocity_kp__Heading, Drive_Distance_Heading_Velocity_kp__Velocity, Drive_Distance_Heading_Velocity_kp__kp):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.set_position(0, DEGREES)\n    BottomLeft.set_position(0, DEGREES)\n    TopRight.set_position(0, DEGREES)\n    BottomRight.set_position(0, DEGREES)\n    if Drive_Distance_Heading_Velocity_kp__Distance > 0:\n        while (TopLeft.position(DEGREES) < Drive_Distance_Heading_Velocity_kp__Distance and TopRight.position(DEGREES) < Drive_Distance_Heading_Velocity_kp__Distance):\n            error = Drive_Distance_Heading_Velocity_kp__Heading - inertial_3.rotation(DEGREES)\n            output = error * Drive_Distance_Heading_Velocity_kp__kp\n            TopLeft.set_velocity((Drive_Distance_Heading_Velocity_kp__Velocity + output), PERCENT)\n            BottomLeft.set_velocity((Drive_Distance_Heading_Velocity_kp__Velocity + output), PERCENT)\n            TopRight.set_velocity((Drive_Distance_Heading_Velocity_kp__Velocity - output), PERCENT)\n            BottomRight.set_velocity((Drive_Distance_Heading_Velocity_kp__Velocity - output), PERCENT)\n            TopLeft.spin(FORWARD)\n            BottomLeft.spin(FORWARD)\n            TopRight.spin(FORWARD)\n            BottomRight.spin(FORWARD)\n            wait(5, MSEC)\n    else:\n        while (TopLeft.position(DEGREES) > Drive_Distance_Heading_Velocity_kp__Distance and TopRight.position(DEGREES) > Drive_Distance_Heading_Velocity_kp__Distance):\n            error = Drive_Distance_Heading_Velocity_kp__Heading - inertial_3.rotation(DEGREES)\n            output = error * Drive_Distance_Heading_Velocity_kp__kp\n            TopLeft.set_velocity((Drive_Distance_Heading_Velocity_kp__Velocity + output), PERCENT)\n            BottomLeft.set_velocity((Drive_Distance_Heading_Velocity_kp__Velocity + output), PERCENT)\n            TopRight.set_velocity((Drive_Distance_Heading_Velocity_kp__Velocity - output), PERCENT)\n            BottomRight.set_velocity((Drive_Distance_Heading_Velocity_kp__Velocity - output), PERCENT)\n            TopLeft.spin(REVERSE)\n            BottomLeft.spin(REVERSE)\n            TopRight.spin(REVERSE)\n            BottomRight.spin(REVERSE)\n            wait(5, MSEC)\n    TopLeft.stop()\n    BottomLeft.stop()\n    TopRight.stop()\n    BottomRight.stop()\n\ndef Backwards_number_Rotations(Backwards_number_Rotations__number):\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    TopLeft.spin_for(REVERSE, Backwards_number_Rotations__number, TURNS, wait=False)\n    TopRight.spin_for(REVERSE, Backwards_number_Rotations__number, TURNS, wait=False)\n    BottomLeft.spin_for(REVERSE, Backwards_number_Rotations__number, TURNS, wait=False)\n    BottomRight.spin_for(REVERSE, Backwards_number_Rotations__number, TURNS, wait=True)\n\ndef when_started1():\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    while True:\n        controller_1.screen.set_cursor(1, 1)\n        controller_1.screen.print(inertial_3.heading(DEGREES), precision=6 if vexcode_controller_1_precision is None else vexcode_controller_1_precision)\n        controller_1.screen.clear_screen()\n        wait(5, MSEC)\n\ndef onauton_autonomous_0():\n    global Velocity, error, output, actual_error, y, vexcode_brain_precision, vexcode_console_precision, vexcode_controller_1_precision\n    inertial_3.calibrate()\n    while inertial_3.is_calibrating():\n        sleep(50)\n    LeftIntake.set_velocity(100, PERCENT)\n    RightIntake.set_velocity(100, PERCENT)\n    RollersMotor.set_velocity(100, PERCENT)\n    IdependantMotor.set_velocity(100, PERCENT)\n    Set_Drive_Velocity_Velocity__25(35)\n    LeftIntake.spin_for(FORWARD, 7.5, TURNS, wait=False)\n    RightIntake.spin_for(FORWARD, 7.5, TURNS, wait=False)\n    RollersMotor.spin_for(FORWARD, 0.5, TURNS, wait=False)\n    Drive_Distance_Heading_Velocity_kp(823, 0, Velocity, 1)\n    wait(0.6, SECONDS)\n    Turn_Left_To_number_Degrees(135)\n    wait(0.6, SECONDS)\n    Drive_Distance_Heading_Velocity_kp(888, -135, Velocity, 1)\n    # Tower1\n    RollersMotor.spin_for(FORWARD, 2.5, TURNS, wait=False)\n    IdependantMotor.spin_for(FORWARD, 2.6, TURNS, wait=True)\n    wait(0.6, SECONDS)\n    Backwards_number_Rotations(1.25)\n    wait(0.6, SECONDS)\n    Turn_Right_To_number_Degrees(0)\n    wait(0.6, SECONDS)\n    Drive_Distance_Heading_Velocity_kp(660, 0, Velocity, 1)\n    Forward_number_Rotations_7C_and_don_t_wait(1.9)\n    LeftIntake.spin_for(FORWARD, 15, TURNS, wait=False)\n    RightIntake.spin_for(FORWARD, 15, TURNS, wait=False)\n    RollersMotor.spin_for(FORWARD, 1.5, TURNS, wait=False)\n    wait(2, SECONDS)\n    Turn_Left_To_number_Degrees(90)\n    wait(0.6, SECONDS)\n    Forward_number_Rotations(0.32)\n    wait(0.4, SECONDS)\n    # Tower2\n    RollersMotor.spin_for(FORWARD, 2.2, TURNS, wait=False)\n    IdependantMotor.spin_for(FORWARD, 2.7, TURNS, wait=True)\n    wait(0.5, SECONDS)\n    Backwards_number_Rotations(1.35)\n    wait(0.6, SECONDS)\n    Turn_Right_To_number_Degrees(0)\n    wait(0.6, SECONDS)\n    Drive_Distance_Heading_Velocity_kp(700, 0, Velocity, 1)\n    Forward_number_Rotations_7C_and_don_t_wait(1.78)\n    LeftIntake.spin_for(FORWARD, 15, TURNS, wait=False)\n    RightIntake.spin_for(FORWARD, 15, TURNS, wait=False)\n    RollersMotor.spin_for(FORWARD, 1.2, TURNS, wait=False)\n    wait(1.8, SECONDS)\n    Strafe_Left_number_Rotations(1)\n    wait(0.4, SECONDS)\n    Turn_Left_To_number_Degrees(45)\n    wait(0.6, SECONDS)\n    Drive_Distance_Heading_Velocity_kp(360, -45, Velocity, 1)\n    # Tower3\n    RollersMotor.spin_for(FORWARD, 2.8, TURNS, wait=False)\n    IdependantMotor.spin_for(FORWARD, 2.7, TURNS, wait=True)\n    wait(0.6, SECONDS)\n    Backwards_number_Rotations(1.1)\n    wait(0.6, SECONDS)\n    Turn_Right_To_number_Degrees(90)\n    wait(0.6, SECONDS)\n    RollersMotor.spin_for(FORWARD, 2, TURNS, wait=False)\n    LeftIntake.spin_for(FORWARD, 2.5, TURNS, wait=False)\n    RightIntake.spin_for(FORWARD, 2.5, TURNS, wait=False)\n    Drive_Distance_Heading_Velocity_kp(1264, 90, Velocity, 1)\n    wait(0.4, SECONDS)\n    Turn_Left_To_number_Degrees(0)\n    wait(0.4, SECONDS)\n    Forward_number_Rotations(0.45)\n    # Tower4\n    LeftIntake.spin_for(FORWARD, 2, TURNS, wait=False)\n    RightIntake.spin_for(FORWARD, 2, TURNS, wait=False)\n    RollersMotor.spin_for(FORWARD, 4, TURNS, wait=False)\n    IdependantMotor.spin_for(FORWARD, 4, TURNS, wait=True)\n    Backwards_number_Rotations(0.4)\n    wait(0.4, SECONDS)\n    Turn_Right_To_number_Degrees(90)\n    wait(0.4, SECONDS)\n    Drive_Distance_Heading_Velocity_kp(500, 90, Velocity, 1)\n    Forward_number_Rotations_7C_and_don_t_wait(2.5)\n    RollersMotor.spin_for(FORWARD, 3.5, TURNS, wait=False)\n    LeftIntake.spin_for(FORWARD, 15, TURNS, wait=False)\n    RightIntake.spin_for(FORWARD, 15, TURNS, wait=False)\n    wait(3, SECONDS)\n    Turn_Left_To_number_Degrees(-45)\n    wait(0.6, SECONDS)\n    Drive_Distance_Heading_Velocity_kp(414, 45, Velocity, 1)\n    # Tower5\n    LeftIntake.spin_for(FORWARD, 0.4, TURNS, wait=False)\n    RightIntake.spin_for(FORWARD, 0.4, TURNS, wait=False)\n    RollersMotor.spin_for(FORWARD, 2.5, TURNS, wait=False)\n    IdependantMotor.spin_for(FORWARD, 2.9, TURNS, wait=True)\n\n# create a function for handling the starting and stopping of all autonomous tasks\ndef vexcode_auton_function():\n    # Start the autonomous control tasks\n    auton_task_0 = Thread( onauton_autonomous_0 )\n    # wait for the driver control period to end\n    while( competition.is_autonomous() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the autonomous control tasks\n    auton_task_0.stop()\n\ndef vexcode_driver_function():\n    # Start the driver control tasks\n    # wait for the driver control period to end\n    while( competition.is_driver_control() and competition.is_enabled() ):\n        # wait 10 milliseconds before checking again\n        wait( 10, MSEC )\n    # Stop the driver control tasks\n\n# register the competition functions\ncompetition = Competition( vexcode_driver_function, vexcode_auton_function )\n\nwhen_started1()\n\n","textLanguage":"python","rconfig":[{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[9],"name":"TopLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[11],"name":"BottomLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[13],"name":"TopRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[12],"name":"BottomRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"IdependantMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1],"name":"RollersMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[10],"name":"LeftIntake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[20],"name":"RightIntake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"inertial_3","customName":false,"deviceType":"Inertial","deviceClass":"inertial","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20211013.15.00.00","appVersion":"2.2.1","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","target":"Physical"}